# Анализ edit/boosters.py и тест-кейс Thermonuclear + Jarvis

## 1. Назначение скрипта

`edit/boosters.py` — цикл, который раз в ~2 секунды начисляет энергию пользователям с активным бустером **Jarvis** и обновляет им `power` (износ станции).

---

## 2. Структура и формулы

### 2.1 Условие попадания в выборку

Пользователь обрабатывается, если:
- `jarvis_expires > now` и не `NULL`
- станция не в строительстве: `building_until < now` или `building_until IS NULL`

### 2.2 Начисление энергии за один тик (одну итерацию цикла)

```python
added_kw = float(u.generation_rate) * float(u.power) / 100 / 1800 * jarvis_percent / 100 * u.sbt_get_jarvis()
```

Смысл:
- `generation_rate` — кВт/час при 100% power.
- `power/100` — текущий коэффициент здоровья (0–1).
- `1800` — число тиков в час при интервале ровно 2 сек: 3600/2 = 1800.
- `jarvis_percent` — из `Booster.n1` (slug=`jarvis`), по умолчанию 100.
- `sbt_get_jarvis()` — 1.0 или 1.05 (premium).

За час при постоянном power и 100% Jarvis/SBT:
`generation_rate * (power/100) * (jarvis_percent/100) * sbt_get_jarvis()` — формула согласована с «кВт/час».

### 2.3 Снижение power за один тик

- Если **Repair Kit активен** — power не снижается (или поднимается до `repair_kit_power_level`).
- Иначе:
  `power = power - (1/3600) * sbt_get_power()` за тик.

При тике раз в 2 сек за час: 1800 тиков → снижение на `0.5 * sbt_get_power()` процентов в час (например, 0.5% при `sbt_get_power() = 1`).

### 2.4 Частота цикла

- Цель: каждые **2 секунды** (`sleep_time = max(2 - elapsed_time, 0)`).
- Фактическая частота зависит от времени выполнения итерации: при `elapsed_time > 2` сон 0, но следующая итерация начнётся позже, т.е. **реальный интервал может быть больше 2 сек**.

---

## 3. Тест-кейс: Thermonuclear + Jarvis

### Исходные данные

- Станция: **Thermonuclear power plant**, `generation_rate = 385` кВт/час.
- Бустер: **Jarvis**.
- **Power в момент начала теста: 100%** (за 30 мин падение ~0.25%, средний power ≈ 100%).
- За **30 минут** сгенерировано: **166.2 kW**.
- Ожидание за 60 минут (с учётом поломки): **383–384 kW**.

### Расчёт «наивного» удвоения

- 166.2 · 2 = **332.4 kW** за час.
- Разница с ожиданием: 385 − 332.4 ≈ **53 kW** в час.
- В сутки: 53 · 24 ≈ **1272 kW** недобора.

---

## 4. Возможные причины погрешности (~53 kW/час)

### 4.1 (Главная гипотеза) Меньше тиков в час, чем 1800

Формула заложена под **ровно 1800 тиков в час** (интервал 2 сек). Если одна итерация цикла в среднем занимает больше 2 секунд (нагрузка на БД, много пользователей с Jarvis, батчи по 50 и т.д.), то за час выполнится **меньше 1800 итераций**.

Пример:
- Фактически в час выполняется не 1800, а около **1552** тиков (т.е. средний интервал ~2.32 сек).
- Тогда за час: 385 · (1552/1800) ≈ **332 kW** — как в твоём тесте.

Вывод: **переменная длительность итерации** (особенно при высокой нагрузке) даёт меньше начислений в час и полностью объясняет недобор ~53 kW/час, если реальный интервал между тиками стабильно выше 2 сек.

### 4.2 Power < 100% — исключено

В тесте power в начале был **100%**. За 30 минут при 0.5%/час power падает на ~0.25%, средний power ≈ 100%. Эта причина не объясняет недобор.

### 4.3 jarvis_percent (n1) < 100

Если в конфиге бустера Jarvis поле `n1` выставлено меньше 100 (например 86), генерация будет пропорционально ниже. Стоит проверить значение `Booster.n1` для slug=`jarvis`.

### 4.4 Комбинация

При фиксированном power=100% остаётся комбинация: **меньше 1800 тиков в час** и/или **jarvis_percent (n1) < 100**. Основной вклад даёт число тиков.

---

## 5. Рекомендации

1. **Логировать интервал между тиками**  
   В начале цикла сохранять `now`, в конце считать `elapsed_time` и при необходимости писать в лог среднее за последние N итераций или перцентили. Так можно проверить, стабильно ли интервал держится около 2 сек.

2. **Проверить конфиг Jarvis**  
   В БД: `Booster.objects.filter(slug='jarvis').values('n1')` — убедиться, что `n1 = 100` (или какое значение задумано).

3. **Учёт реального интервала в формуле (опционально)**  
   Если нужна строгая привязка к календарному времени, а не к числу тиков, можно начислять за фактический интервал, например:
   - хранить `last_tick_time` по юзеру или глобально;
   - считать `delta_sec = (now - last_tick_time).total_seconds()`;
   - в формуле вместо фиксированного `1/1800` использовать `delta_sec / 3600` (доля часа).
   Тогда даже при редких тиках начисление за час будет стремиться к 385 · (power/100) · … кВт.

---

## 6. Краткий вывод по тест-кейсу

- **Ожидаемо за час при 100% power и 1800 тиках:** 385 kW (или 383–384 с учётом небольшого падения power).
- **Фактически по удвоению 30 мин:** 332.4 kW.
- **Power в тесте был 100%** — эта причина отбрасывается.
- **Наиболее вероятная причина недобора ~53 kW/час:** цикл выполняется реже, чем раз в 2 секунды (меньше 1800 тиков в час), из-за времени выполнения итерации и нагрузки на БД. Дополнительно проверить `jarvis_percent` (n1) в конфиге Jarvis.

Документ можно использовать вместе с `docs/JARVIS_LOGIC_ANALYSIS.md` для полной картины по Jarvis и boosters.
