# План разработки системы Energy Run (Раннер)

## Обзор

Данный документ описывает план разработки системы раннера для сбора энергии. Система должна обеспечивать безопасное списание storage при старте забега и надежное начисление энергии по завершению забега.

## Текущее состояние

### Фронтенд
- ✅ Кнопка "Старт" вызывает `POST /energy-run-start/`
- ✅ Забег отслеживает собранную энергию (`energyCollected`)
- ✅ При завершении вызывается `POST /game-run-complete/` (но эндпоинт еще не реализован)
- ✅ Storage используется для ограничения максимального количества собираемой энергии

### Бэкенд
- ✅ `EnergyRunStartView` - записывает `energy_run_last_started_at` и проверяет cooldown (60 минут)
- ❌ `GameRunCompleteView` - **НЕ РЕАЛИЗОВАН**
- ✅ `TapEnergyView` - пример начисления энергии при тапах (используется как референс)

## Требования

### 1. При старте забега (`energy-run-start/`)
- ✅ Записать `energy_run_last_started_at` (уже реализовано)
- ✅ Проверить cooldown 60 минут (уже реализовано)
- ❌ **СПИСАТЬ storage (обнулить)** - нужно добавить
- ❌ **Сохранить начальное значение storage** для валидации при завершении

### 2. При завершении забега (`game-run-complete/`)
- ❌ Валидация данных от клиента (защита от читерства)
- ❌ Начислить собранную энергию на баланс `energy`
- ❌ Добавить энергию в `WalletInfo.kw_amount` (синхронизация с кошельком)
- ❌ Учесть логику сохранения энергии при проигрыше (процент от уровня инженера)

### 3. Безопасность
- ❌ Валидация максимального количества энергии (не больше чем было в storage при старте)
- ❌ Проверка времени забега (разумные лимиты)
- ❌ Проверка что забег был начат (существует `energy_run_last_started_at`)
- ❌ Защита от повторного завершения одного забега

## План разработки

### Этап 1: Модификация `EnergyRunStartView`

**Файл:** `edit/core/views.py`

**Изменения:**
1. При успешной проверке cooldown:
   - Сохранить текущее значение `storage` в новое поле `energy_run_start_storage` (или использовать временное хранилище)
   - Обнулить `storage`: `storage = 0`
   - Записать `energy_run_last_started_at`

**Варианты реализации хранения начального storage:**
- **Вариант A (рекомендуется):** Добавить поле `energy_run_start_storage` в модель `UserProfile`
- **Вариант B:** Использовать Redis/cache с ключом `energy_run_storage_{user_id}` и TTL 2 часа
- **Вариант C:** Хранить в JSON поле `energy_run_data` в `UserProfile`

**Рекомендация:** Вариант A - самое надежное решение, но требует миграцию БД.

### Этап 2: Создание `GameRunCompleteView`

**Файл:** `edit/core/views.py`

**Новый класс:**
```python
class GameRunCompleteView(APIView):
    """Завершение забега и начисление энергии"""
    
    @require_auth
    def post(self, request):
        # 1. Валидация входных данных
        # 2. Проверка что забег был начат
        # 3. Валидация собранной энергии (не больше начального storage)
        # 4. Расчет финальной энергии с учетом win/lose
        # 5. Начисление на баланс energy
        # 6. Обновление WalletInfo.kw_amount
        # 7. Очистка временных данных забега
        # 8. Возврат результата
```

**Валидация:**
- `energy_collected` не может быть отрицательным
- `energy_collected` не может быть больше `energy_run_start_storage`
- `run_duration` должен быть в разумных пределах: минимум 5 секунд, максимум 2 часа (7200 секунд) - забег может длиться больше 45 минут
- `distance` должен быть положительным
- Проверка что `energy_run_last_started_at` существует и не слишком старый (не старше 2 часов от текущего времени)

**Логика начисления:**
- Если `is_win = True` (пользователь дошел до конца): начислить всю `energy_collected`
- Если `is_win = False` (проигрыш): применить процент сохранения от уровня инженера (как в `TapEnergyView`)
- Обновить `energy = energy + final_energy_amount`
- Обновить `WalletInfo.kw_amount = kw_amount + final_energy_amount`
- Обновить статистику: `GlobalSpendStats.total_energy_accumulated`

**Защита от повторного завершения:**
- После успешного завершения очистить `energy_run_start_storage` или пометить забег как завершенный
- Можно использовать флаг `energy_run_completed_at` или проверять что `energy_run_start_storage` еще существует

### Этап 3: Добавление поля в модель UserProfile

**Файл:** `edit/core/models.py`

**Новое поле:**
```python
energy_run_start_storage = models.DecimalField(
    max_digits=36, 
    decimal_places=16, 
    default=0,
    null=True,
    blank=True,
    help_text="Storage при старте забега (для валидации)"
)
```

**Миграция:**
- Создать файл миграции: `python manage.py makemigrations`
- **Примечание:** Миграция будет применена на сервере после передачи измененных файлов

### Этап 4: Обновление URL роутинга

**Файл:** `edit/core/urls.py`

**Добавить:**
```python
from .views import GameRunCompleteView

urlpatterns = [
    # ... существующие пути
    path("game-run-complete/", GameRunCompleteView.as_view(), name="game_run_complete"),
]
```

### Этап 5: Обновление фронтенда (опционально)

**Файл:** `src/views/GameRunView.vue`

**Изменения в `handleClaim`:**
- Убрать TODO комментарий
- Убедиться что вызывается `gameRun.completeRun()` перед `exitToMain()`
- Обработать ошибки от сервера

**Файл:** `src/composables/useGameRun.js`

**Проверка:**
- Убедиться что `completeRun()` отправляет правильные данные
- Проверить что `energy_collected` ограничивается `currentStorage.value`

## Детальная реализация GameRunCompleteView

### Структура запроса от клиента:
```json
{
  "distance": 1250.5,
  "energy_collected": 45.3,
  "run_duration": 45.2,
  "obstacles_hit": 2,
  "power_used": 5.0,
  "is_win": true  // или false при проигрыше
}
```

### Структура ответа:
```json
{
  "success": true,
  "message": "Run completed successfully",
  "energy_gained": 45.3,
  "total_energy": 150.5,
  "storage": 0,
  "power": 95.0,
  "bonuses": null,
  "penalties": null
}
```

### Логика валидации:
1. Проверить что `energy_run_last_started_at` существует
2. Проверить что `energy_run_start_storage` существует (забег был начат)
3. Проверить что `energy_collected <= energy_run_start_storage`
4. Проверить что `run_duration` в пределах 5-7200 секунд (5 секунд - 2 часа, так как забег может длиться больше 45 минут)
5. Проверить что `distance > 0`
6. Проверить что забег был начат не более 2 часов назад (защита от старых забегов)

### Логика начисления:
```python
# 1. Определить финальное количество энергии
if is_win:
    final_energy = energy_collected
else:
    # Применить процент сохранения от уровня инженера
    engineer_level = user_profile.get_real_engs()
    eng_config = EngineerConfig.objects.get(level=engineer_level)
    saved_percent = eng_config.saved_percent_on_lose
    final_energy = energy_collected * (saved_percent / 100)

# 2. Начислить на баланс
UserProfile.objects.filter(user_id=user_profile.user_id).update(
    energy=F("energy") + final_energy
)

# 3. Обновить WalletInfo
WalletInfo.objects.filter(
    user=user_profile, 
    wallet=user_profile.ton_wallet
).update(kw_amount=F("kw_amount") + final_energy)

# 4. Обновить статистику
GlobalSpendStats.objects.update(
    total_energy_accumulated=F("total_energy_accumulated") + final_energy
)

# 5. Очистить данные забега
UserProfile.objects.filter(user_id=user_profile.user_id).update(
    energy_run_start_storage=None
)
```

## Защита от читерства

### 1. Валидация на сервере
- ✅ Максимальное количество энергии ограничено начальным storage
- ✅ Проверка времени забега (минимум 5 секунд, максимум 2 часа / 7200 секунд - забег может длиться больше 45 минут)
- ✅ Проверка что забег был начат

### 2. Дополнительные меры защиты
- Логирование всех завершений забегов для анализа аномалий
- Rate limiting на эндпоинт (например, максимум 1 запрос в минуту)
- Проверка последовательности: нельзя завершить забег без старта
- Проверка что storage был обнулен при старте (дополнительная валидация)

### 3. Мониторинг
- Логировать все завершения забегов с данными:
  - `user_id`
  - `energy_collected`
  - `energy_run_start_storage`
  - `final_energy`
  - `run_duration`
  - `is_win`

## Тестирование

### Тест-кейсы:

1. **Успешное завершение забега (win):**
   - Старт: storage = 65 kW
   - Собрано: 45.3 kW
   - Ожидаемый результат: начислено 45.3 kW на баланс и в wallet

2. **Завершение забега (lose):**
   - Старт: storage = 65 kW
   - Собрано: 45.3 kW
   - Уровень инженера: 10 (saved_percent_on_lose = 50%)
   - Ожидаемый результат: начислено 22.65 kW (45.3 * 0.5)

3. **Попытка подменить значение:**
   - Старт: storage = 65 kW
   - Клиент отправляет: energy_collected = 100 kW
   - Ожидаемый результат: ошибка валидации

4. **Попытка завершить без старта:**
   - Клиент отправляет завершение без предварительного старта
   - Ожидаемый результат: ошибка "Run not started"

5. **Повторное завершение:**
   - Завершить забег дважды
   - Ожидаемый результат: второй запрос возвращает ошибку

6. **Длительный забег (больше 45 минут):**
   - Старт: storage = 65 kW
   - Забег длится 50 минут (3000 секунд)
   - Собрано: 45.3 kW
   - Ожидаемый результат: успешное завершение и начисление энергии (валидация времени должна пройти)

## Порядок выполнения

1. ✅ Создать план разработки (этот документ)
2. ⏳ Добавить поле `energy_run_start_storage` в модель `UserProfile`
3. ⏳ Создать файл миграции (будет применена на сервере)
4. ⏳ Модифицировать `EnergyRunStartView` для списания storage
5. ⏳ Создать `GameRunCompleteView` с полной логикой
6. ⏳ Добавить URL роутинг
7. ⏳ Протестировать на dev окружении
8. ⏳ Обновить фронтенд при необходимости
9. ⏳ Передать файлы на сервер и применить миграцию
10. ⏳ Деплой на production

## Примечания

- При обнулении storage нужно убедиться что это не влияет на другие системы
- Логика сохранения энергии при проигрыше должна совпадать с логикой в `TapEnergyView`
- Важно синхронизировать `energy` и `WalletInfo.kw_amount` как при тапах
- Рассмотреть возможность добавления статистики забегов (количество, средняя дистанция и т.д.)
- **Забег может длиться больше 45 минут** - максимальное время валидации установлено в 2 часа (7200 секунд)
- **Миграции будут выполнены на сервере** - файл миграции будет создан локально, но применен только после передачи на сервер
