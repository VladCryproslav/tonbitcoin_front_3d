# Анализ системы перегревов и план переноса на генерацию энергии

## 1. Текущая система перегревов (во время забега)

### 1.1 Где реализована

- **Файл:** `src/views/GameRunView.vue`
- **Флаг включения:** `src/services/data.js` — `runnerOverheatEnabled` (сейчас **false** — перегревы в раннере отключены).

### 1.2 Логика работы

1. **Инициализация при старте забега** (`initializeOverheat`, ~строки 1298–1370):
   - Если `!runnerOverheatEnabled` — все флаги перегрева сбрасываются, проверки не выполняются.
   - Проверяется тип станции: перегрев только для станций из `OVERHEAT_HOURS_BY_TYPE` (Thermal, Geothermal, Nuclear, Thermonuclear, Dyson Sphere). Для остальных (в т.ч. Hydro/Orbital) перегрев не используется.
   - Если активна криокамера (`cryo_expires` > now) — перегрев отключен.
   - Состояние подтягивается с сервера: `overheat_energy_collected`, `was_overheated`, `overheat_goal`, `overheated_until`. Если `overheated_until` в будущем — показывается модалка перегрева и ставится пауза.

2. **Конфигурация по типам станций** (строки 636–642):

   ```js
   const OVERHEAT_HOURS_BY_TYPE = {
     "Thermal power plant": 4,        // ~6 перегревов в сутки
     "Geothermal power plant": 2,    // ~12 перегревов в сутки
     "Nuclear power plant": 2,
     "Thermonuclear power plant": 1,  // ~24 перегрева в сутки
     "Dyson Sphere": 1,
   }
   ```

3. **Триггер перегрева во время забега** (строки 1899–1919, 1374–1408):
   - В колбэке сбора энергии с дорожки (`gameWorld.updateCollectibles`) при каждом собранном токене вызывается `checkOverheatTrigger(energy)`.
   - Запрос на бэкенд: `POST game-run-update-overheat/` с `{ amount: energy }`. Сервер накапливает `overheat_energy_collected` и при достижении порога возвращает `overheated: true` и `overheated_until`.
   - При `overheated === true` вызывается `activateOverheat(serverData)`.

4. **Активация перегрева** (`activateOverheat`, ~1412–1535):
   - Устанавливаются локальные refs: `isOverheated`, `overheatedUntil`, `wasOverheated`, `overheatEnergyCollected`, `overheatGoal`.
   - Вибрация (если включена).
   - Запускается обратный отсчёт 5 → 4 → 3 → 2 → 1 сек. На 4 сек включается защита от коллизий и мигание, на 2 сек — плавное замедление, на 1 сек — остановка забега, пауза, показ модалки перегрева.

5. **Модальное окно в раннере:** `src/components/OverheatGameRunModal.vue`:
   - Показывает заголовок/описание перегрева, кнопку «Продолжить» (активна только после окончания перегрева) и опционально «Купить азот» (снять перегрев за Stars/fBTC).
   - Периодическая проверка `overheatedUntil` (раз в секунду) — при окончании перегрева состояние обновляется через `app.initUser()`, модалка не закрывается автоматически; пользователь нажимает «Продолжить».

6. **Продолжение после перегрева** (`handleOverheatContinue`, ~1538–1592):
   - Проверка серверного и локального `overheated_until`; при активном перегреве выход без действий.
   - При окончании перегрева: `POST game-run-reset-overheat-flag/`, `app.initUser()`, сброс локальных флагов, вызов `resumeGame()` (таймер 3-2-1 и возобновление забега).

7. **Дополнительно в GameRunView:**
   - Интервал раз в секунду (`overheatCheckInterval`, ~3104–3146): при открытой модалке перегрева проверяет окончание `overheatedUntil`, при необходимости обновляет данные через `app.initUser()` и локальное состояние (модалку не закрывает).
   - При размонтировании — очистка `overheatCheckInterval` и `overheatCountdownInterval`.

### 1.3 API, используемые в раннере

| Эндпоинт | Назначение |
|----------|------------|
| `POST game-run-update-overheat/` | Передать собранную в забеге энергию; сервер решает, наступил ли перегрев. |
| `POST game-run-reset-overheat-flag/` | Сброс флага перегрева после окончания охлаждения (или после азота). |

### 1.4 Состояние в store

- **app.user:** `overheated_until`, `overheat_energy_collected`, `was_overheated`, `overheat_goal` (и при необходимости `cryo_expires`). Мутация: `app.setOverheatedUntil(newValue)` в `src/stores/app.js`.

### 1.5 Длительность перегрева (охлаждения)

По текущей логике бэкенда длительность перегрева — **от 30 до 300 секунд** в случайном порядке: при наступлении перегрева сервер вычисляет `duration = random.randint(min_duration, max_duration)` (в секундах) и выставляет `overheated_until = now + timedelta(seconds=duration)`.

- **Конфиг:** модель `OverheatConfig` (бэкенд): поля `min_duration` и `max_duration` в **секундах**. Типичные значения: 30–300 сек (от 0,5 до 5 минут).
- Фронт только отображает `overheated_until`; пользователь ждёт окончания этого интервала, затем нажимает включение станции (HeatSwitch → `enable-station/`).

---

## 2. Перегревы при генерации энергии (EnergizerView_example / EnergizerView)

### 2.1 Где используется

- **Пример/референс UI:** `src/views/EnergizerView_example.vue`
- **Реальный экран:** `src/views/EnergizerView.vue` (часть логики перегрева закомментирована или упрощена).

### 2.2 Важно: тапов больше нет. Триггер перегрева

**Перегрев должен наступать не от тапов, а в момент заполнения Storage до Storage limit** в процессе генерации энергии (по заданным условиям: тип станции, период по `OVERHEAT_HOURS_BY_TYPE`, без криокамеры).

- Генерация идёт по `generation_rate` (из `gen_config`/`gen_configs`), Storage растёт до `storage_limit`.
- Бэкенд при начислении энергии (по таймеру/тикам) проверяет: если накопленная энергия за период достигла порога перегрева **или** в момент достижения Storage = storage_limit выполнены условия перегрева — выставляется `overheated_until` и при необходимости отправляется уведомление в Telegram.
- Фронт только отображает состояние из `app.user.overheated_until` и после окончания перегрева показывает кнопку включения станции (AfterHeatModal → HeatSwitch → `enable-station/`).

### 2.3 Текущая логика в EnergizerView_example (для отображения и «включить станцию»)

1. **Раньше был тап** `increment()` → `POST tap-energy/` с обработкой 400 и `overheated_until`. Тапов нет — триггер перегрева только на бэкенде при заполнении Storage до лимита.

2. **Отображение перегрева на экране:**
   - Блок `.overheat` (строки 1959–1963): показывается при `app?.user?.overheated_until` (иконка, заголовок, описание из `general.main.overheat_*`).
   - Класс `heated` на изображении станции при активном перегреве (строка 2058).
   - **Пока активный перегрев — кнопки «Собрать энергию» нет** (скрыта).

3. **После окончания перегрева:**
   - В `watch(app, ...)` при `overheat_date <= curr_date` выставляется `openHeatCheck.value = true` и через 1 с — `openAfterHeat.value = true`.
   - Показывается **AfterHeatModal** (прогресс-бар ~5 сек), по закрытию — **HeatSwitch** (кнопка «включить станцию»).
   - По закрытию HeatSwitch вызывается `POST enable-station/`, затем `app.init()` и сброс `openHeatCheck`.

Итого: перегрев наступает на бэкенде при заполнении Storage до лимита; во время перегрева показывается блок с предупреждением и **кнопки «Собрать энергию» нет**; после охлаждения — модалка «охлаждение закончилось», затем кнопка включения станции (`enable-station/`).

### 2.3 Компоненты

- **OverHeatModal** (`src/components/OverHeatModal.vue`) — простой тост перегрева (автозакрытие через 2 с); в примере не используется в текущем потоке тапов.
- **AfterHeatModal** — «охлаждение закончилось», через 5 с закрывается с `{ showSwitch: true }`.
- **HeatSwitch** — UI «включить станцию»; по переключению вызывается `enable-station/`.

---

## 3. MinerView и отправка сообщения в бот при отключении интернета

### 3.1 Логика в MinerView при отключении интернета

- **Файл:** `src/views/MinerView.vue`
- При обрыве интернет-соединения майнинг на сервере останавливается. Бэкенд выставляет у пользователя флаг **`mining_was_stopped`** и **`stop_mining_activate_last`** (время последней попытки активации; используется 10-минутный таймаут перед повторным «Подключить»).
- Текст в локалях (`modals.mining_stopped.message`): *«Было прервано интернет-соединение, что привело к остановке майнинга.»* (RU) / *«Internet connection was interrupted, which led to the mining stop.»* (EN).
- **Во фронте:** отображается блок с состоянием ошибки и кнопкой «Подключить» (`reconnectMining` → ReconnectModal с примером, затем `checkReconnect`). Кнопка заблокирована на 10 минут после `stop_mining_activate_last` (строки 1691–1708).
- **Отправка сообщения в бот:** выполняется на **бэкенде** в момент, когда майнинг помечается как остановленный из-за потери связи. Фронт только показывает состояние `app.user.mining_was_stopped` и кнопку переподключения; вызов API к боту с текстом «зайдите в приложение» делается сервером.

Использовать ту же схему для перегрева: при установке `overheated_until` на бэкенде отправлять пользователю сообщение в Telegram (тот же канал/механизм, что и при остановке майнинга из-за отключения интернета).

### 3.2 Текст сообщения в бот при перегреве

- **RU:** «Ваша электростанция перегрелась. Зайдите в приложение, дождитесь окончания охлаждения и нажмите кнопку включения станции.»
- **EN:** «Your power station has overheated. Open the app, wait for cooling to finish, then tap the button to turn the station back on.»
- **UK:** «Ваша електростанція перегрілась. Зайдіть у додаток, дочекайтесь завершення охолодження та натисніть кнопку ввімкнення станції.»

---

## 4. Раннер не участвует в перегреве (GameRunView)

### 4.1 Требование

**Раннер вообще не участвует в перегреве.** Ни модалка перегрева, ни пауза при активном перегреве, ни проверки при старте забега — перегрев живёт только на экране генерации энергии (EnergizerView).

### 4.2 Что отключить / убрать в коде (при внедрении)

1. **Оставить флаг:** в `src/services/data.js` оставить `runnerOverheatEnabled = false`.
2. В **GameRunView** убрать или не вызывать: `initializeOverheat()`, `checkOverheatTrigger`, показ OverheatGameRunModal при активном перегреве, интервал `overheatCheckInterval`, логику паузы/продолжения из-за перегрева. Раннер не читает и не отображает `overheated_until`.

### 4.3 Документирование

- В коде (или в комментарии в `GameRunView.vue`) указать: «Раннер не участвует в перегреве. Перегрев только при генерации энергии (см. docs/OVERHEAT_SYSTEM_ANALYSIS.md).»

---

## 5. Новая система: перегревы во время генерации энергии

### 5.1 Цель

- Сохранить текущую **логику** перегрева (типы станций, интервалы по часам, криокамера, `overheated_until`, сброс флага, азот), но привязать её к **генерации энергии** (тапы / авто-генерация), а не к сбору энергии в забеге.
- За заданный период для каждой станции по-прежнему наступает перегрев по той же схеме (частота из `OVERHEAT_HOURS_BY_TYPE` или эквивалент на бэкенде).

### 5.2 Где триггерить перегрев (тапов нет)

- **Триггер:** в момент **заполнения Storage до Storage limit** в процессе генерации энергии (по заданным условиям: тип станции из `OVERHEAT_HOURS_BY_TYPE`, учёт периода/частоты перегревов, без криокамеры). Генерация идёт по `generation_rate`; бэкенд при начислении энергии (по времени/тикам) проверяет достижение storage_limit и порога перегрева — при выполнении условий выставляет `overheated_until` и отправляет сообщение в бот (как при остановке майнинга из-за отключения интернета в MinerView).
- **Длительность перегрева (охлаждения):** **от 30 до 300 секунд** в случайном порядке (OverheatConfig.min_duration / max_duration на бэкенде). Ожидание после перегрева — от 0,5 до 5 минут, затем пользователь нажимает включение станции.
- Клиент не инициирует перегрев; при следующем запросе (initUser, открытие экрана генерации, enable-station и т.п.) получает обновлённого user с `overheated_until` и отображает блок перегрева и после охлаждения — кнопку включения станции.

### 5.3 Единое состояние перегрева

- Один источник правды: **backend** и **app.user** (`overheated_until`, `overheat_energy_collected`, `was_overheated`, `overheat_goal`).
- **Раннер в перегреве не участвует:** никакой логики перегрева в GameRunView (ни модалка, ни пауза, ни чтение `overheated_until` при старте забега). Перегрев только на экране генерации энергии.
- Экран генерации (EnergizerView) при загрузке/обновлении user получает `overheated_until` из бэкенда и показывает блок перегрева; после окончания перегрева — AfterHeatModal → HeatSwitch → `enable-station/`.

### 5.4 UI при перегреве во время генерации

- Использовать текущий поток из **EnergizerView_example**:
  - Блок перегрева над станцией (`app?.user?.overheated_until`).
  - Класс `heated` на изображении станции.
  - **Пока активный перегрев — кнопки «Собрать энергию» нет** (скрыта).
  - После окончания перегрева: **AfterHeatModal** → **HeatSwitch** → `enable-station/`.
- Раннер перегрев не показывает и не обрабатывает (см. п. 5.3).

### 5.5 Telegram-уведомление

- При установке `overheated_until` на бэкенде отправлять пользователю сообщение в Telegram **тем же механизмом, что и при отключении интернета в MinerView** (бэкенд при событии «майнинг остановлен» уже шлёт уведомление в бот; для перегрева — тот же канал, другой текст).
- Текст сообщения — п. 3.2 (перегрев, зайти в приложение, дождаться охлаждения, нажать кнопку включения станции).

### 5.6 Оптимизация и сохранение логики

- **Не трогать:** формулы и константы перегрева на бэкенде, типы станций, криокамеру, азот, `overheated_until`, `game-run-reset-overheat-flag`, `enable-station`, модалки и кнопку включения станции.
- **Отключить только:** вызов триггера перегрева в GameRunView (оставить `runnerOverheatEnabled = false` и не вызывать проверку при сборе энергии в забеге).
- **Добавить/перенести:** триггер перегрева на бэкенде в момент заполнения Storage до storage_limit при начислении энергии по `generation_rate`; при установке `overheated_until` — отправка сообщения в бот (как при `mining_was_stopped` в MinerView). Тапов нет.

---

## 6. Краткий чеклист для внедрения

| Задача | Действие |
|--------|----------|
| Отключить перегревы в забеге | Оставить `runnerOverheatEnabled = false`; при необходимости добавить комментарий/ссылку на этот документ. |
| Перегревы при генерации | Триггер на бэкенде в момент заполнения Storage до storage_limit (тапов нет); при установке `overheated_until` отправлять в бот сообщение по той же схеме, что при отключении интернета в MinerView; клиент показывает UI из EnergizerView_example. |
| UI генерации | Блок перегрева + **при активном перегреве кнопки «Собрать энергию» нет** + после охлаждения AfterHeatModal → HeatSwitch → enable-station. |
| Раннер | Не участвует в перегреве: не показывать модалку, не ставить на паузу, не читать overheated_until. |
| Telegram | Использовать ту же логику, что при отключении интернета в MinerView: бэкенд при установке перегрева отправляет сообщение в бот пользователю; текст — см. п. 3.2. |

---

## 7. Пример: Nuclear power plant за 24 часа (сбор каждые 4 часа)

**Параметры станции:** `storage_limit = 875` kW, `generation_rate = 220` kW/h.  
**Nuclear power plant:** в конфиге перегрев раз в 2 ч (до 12 перегревов в сутки).  
**Условие:** пользователь заходит и снимает энергию с Storage **каждые 4 часа** (0:00, 4:00, 8:00, 12:00, 16:00, 20:00, 24:00).

### Расчёт

- Время заполнения Storage до лимита: **875 / 220 ≈ 3 ч 59 мин**.
- То есть примерно за **4 часа** накапливается 875 kW и срабатывает перегрев (бэкенд выставляет `overheated_until`, скрывается кнопка «Собрать энергию», уходит уведомление в бот).
- **Длительность охлаждения:** по логике бэкенда — **случайно от 30 до 300 секунд** (OverheatConfig.min_duration / max_duration). В примере для наглядности возьмём один из вариантов: например, 2 минуты (120 сек).

### Сценарий по шагам

| Время   | Событие |
|--------|--------|
| **0:00** | Пользователь забирает энергию, Storage = 0. Генерация стартует. |
| **~3:59** | Storage = 875 → **перегрев**. Бэкенд ставит `overheated_until = now + random(30…300)` сек (например, +2 мин → до ~4:01). Кнопка «Собрать энергию» скрыта. В Telegram уходит сообщение о перегреве. |
| **4:00** | Пользователь заходит. Видит перегрев (охлаждение до ~4:01). Кнопки «Собрать энергию» нет. Ждёт окончания охлаждения (30–300 сек в рандоме). |
| **~4:01** | Охлаждение закончилось. AfterHeatModal → HeatSwitch → пользователь нажимает включение станции (`enable-station/`). Storage = 0, генерация снова идёт. |
| **8:00** | За ~3 ч с момента включения (~4:01) накопилось **220 × 3 ≈ 660** kW. Пользователь забирает **660** kW. Storage = 0. |
| **~11:59** | С 8:00 прошло 875/220 ≈ 3 ч 59 мин → Storage = 875 → **перегрев**. `overheated_until` снова now + (30…300) сек. Кнопка «Собрать энергию» скрыта. |
| **12:00** | Пользователь заходит. Перегрев, снять нельзя. Ждёт окончания охлаждения (30–300 сек), затем включает станцию. |
| **16:00** | За ~3 ч после включения накопилось **660** kW. Пользователь забирает **660** kW. Storage = 0. |
| **~19:59** | С 16:00 прошло ~3 ч 59 мин → Storage = 875 → перегрев. |
| **20:00** | Перегрев, снять нельзя. После охлаждения (30–300 сек) — включение станции. |
| **24:00** | За ~3 ч накопилось **660** kW. Пользователь забирает **660** kW. |

### Итог за 24 часа

- **Сбор энергии по расписанию 4 ч:** в моменты **4:00, 12:00, 20:00** пользователь приходит уже после срабатывания перегрева (~3:59, ~11:59, ~19:59) — кнопки «Собрать энергию» нет, забирать нечего. В моменты **8:00, 16:00, 24:00** пользователь успевает снять по **660** kW (3 ч генерации после предыдущего включения станции).
- **Снято за сутки:** 660 × 3 = **1980** kW (вместо теоретических 875 × 6 = 5250 kW при сборе ровно каждые 4 ч без перегрева).
- **Перегревов за сутки:** 3 (каждый раз при достижении Storage = 875; частота ограничена тем, что пользователь включает станцию только после охлаждения и следующего визита).

Чем чаще пользователь заходит и снимает энергию (не давая Storage доходить до 875), тем реже срабатывает перегрев. Если бы он забирал энергию, например, каждые 3 часа, перегрев бы не наступал (3 × 220 = 660 < 875).

**Длительность охлаждения:** в каждом перегреве — **случайная от 30 до 300 секунд** (задаётся на бэкенде в OverheatConfig: `min_duration` / `max_duration` в секундах). Ожидание после перегрева — от 0,5 до 5 минут в рандомном порядке.

---

*Документ подготовлен по результатам анализа кодовой базы. Правки в коде по этому плану пока не вносились.*
