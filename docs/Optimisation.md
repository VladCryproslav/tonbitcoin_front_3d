# Анализ оптимизации раннера

## Критические логические ошибки (мешают оптимизации и стабильности)

### 1. Утечка объектов при повторном старте забега (useGameWorld.js)

**Проблема:** При каждом вызове `startGame()` вызывается `clearAll()` + `createRoad()`. `clearAll()` удаляет только obstacles и collectibles. `createRoad()` не очищает старые `roadSegments`, `laneMarkings` и не удаляет из сцены старый фон (небо, барьеры, маркеры).

**Результат:** При втором и последующих забегах в сцене накапливаются:
- дубликаты сегментов дороги (7 → 14 → 21 …);
- дубликаты разметки полос (десятки лишних мешей);
- дубликаты фона (3 неба, 2 барьера, 20 маркеров каждый раз).

Это даёт рост draw calls и падение FPS после нескольких перезапусков.

**Исправление:** Перед созданием новой дороги удалять старые объекты:
- в `createRoad()` в начале: удалить из scene и очистить `roadSegments.value`, `laneMarkings.value`;
- фон создавать один раз при первой инициализации мира, либо при createRoad сначала удалять старые объекты фона (хранить ссылки на sky/barriers/markers и при повторном createRoad удалять их из scene).

---

### 2. getPlayerBox() и updateEffects вызываются многократно за кадр (GameRunView.vue)

**Проблема:** В `doOneStep()` вызываются:
- `gamePhysics.value.getPlayerBox()` — дважды (для updateObstacles и updateCollectibles);
- `gameEffects.value.updateEffects()` — один раз за шаг.

При фиксированном шаге до 3 шагов за кадр (MAX_STEPS = 3) получается до 6 вызовов `getPlayerBox()` (каждый раз `setFromObject` по всей иерархии меша) и до 3 вызовов `updateEffects()`.

**Результат:** Лишние вычисления AABB и многократное обновление одних и тех же эффектов по времени (логика эффектов привязана к Date.now(), а не к игровому времени).

**Исправление:**
- Вычислять `playerBox` один раз за вызов `doOneStep()` и передавать один и тот же объект в `updateObstacles` и `updateCollectibles`.
- Вызывать `updateEffects()` один раз за кадр (в блоке rAF после цикла фиксированных шагов), а не внутри `doOneStep()`.

---

### 3. Shake камеры через 10 requestAnimationFrame (GameRunView.vue)

**Проблема:** При столкновении запускается цикл из 10 rAF подряд только для тряски камеры. Это конкурирует с основным игровым циклом и может вызывать микрофризы и двойной рендер в один кадр.

**Исправление:** Реализовать тряску камеры внутри основного цикла: хранить `shakeEndTime` и в основном rAF до этого времени смещать camera.position на случайный вектор, затем сбрасывать.

---

### 4. updateLaneMarkings — три прохода по массиву (useGameWorld.js) ✅

**Проблема:** Три последовательных `laneMarkings.value.forEach`: первый двигает все разметки, второй собирает minZ по полосам, третий переносит ушедшие.

**Исправление (сделано):** Два прохода: в первом двигаем все разметки (`position.z += roadSpeed`) и по ходу считаем minZ по полосам для разметок с z <= 10; во втором переносим ушедшие (z > 10) на `minZ - stepZ + 0.05` по своей полосе.

**Важно — логика разметки (не ломать):** Разметка должна иметь одну скорость и один источник обновления. Обновление только в `updateLaneMarkings()`, вызываемом из `updateRoad()`, с `roadSpeed.value`. Если разметку двигать из двух мест или двумя разными скоростями, возникает баг «два шара»: один «шар» разметки едет со скоростью игрока/камеры, второй — с дорогой, визуально разъезжаются. При оптимизации не менять: (1) вызов только из updateRoad; (2) единственное изменение позиции — `position.z += roadSpeed.value`; (3) телепорт ушедших (z > 10) в хвост полосы по minZ.

---

### 5. Удаление из массивов obstacles/collectibles (useGameWorld.js)

**Проблема:** В `updateObstacles` и `updateCollectibles` при удалении строится массив индексов, затем `filter` создаёт новый массив. При частых удалениях — лишние аллокации. Плюс в цикле `scene.remove` вызывается сразу — порядок индексов в `obstaclesToRemove` не обратный, но filter по Set корректен. Аллокация нового массива каждый кадр при хотя бы одном удалении — нагрузка на GC.

**Исправление:** Object pool для препятствий и коллектов: не удалять меши, а деактивировать (visible = false, position в пул) и переиспользовать при спавне. Тогда не нужно каждый раз делать filter и аллокации.

---

## Рекомендуемые оптимизации (без изменения разметки дороги)

### A. Переиспользование геометрии и материалов (useGameWorld.js)

**Сейчас:** Каждое препятствие — новый `BoxGeometry(1, height, 1)` и новый `MeshStandardMaterial`. Коллекты — два куба с новыми геометриями и материалами. Десятки одинаковых разметок — каждый со своей геометрией и материалом.

**Рекомендации:**
- **Разметка:** Одна общая геометрия и один материал для всех линий разметки; для каждого меша использовать `new Mesh(sharedMarkingGeometry, sharedMarkingMaterial)` и только менять matrix/position.
- **Препятствия:** По типам (JUMP, ROLL, IMPASSABLE) — одна геометрия на тип (по высоте может быть 2 варианта: 0.9 и 2.5), материалы — один на цвет (или один материал с vertex color, если нужны разные цвета). При создании препятствия — `new Mesh(sharedObstacleGeometry[kind], sharedObstacleMaterial[kind].clone())` если нужны разные цвета, иначе один материал на тип.
- **Коллекты:** Одна геометрия внешнего куба, одна внутреннего; один материал внешнего, один внутреннего. Группу создавать из двух мешей с shared geometry/material, только position/rotation задавать при спавне.

Это снижает количество draw calls и объём памяти (меньше уникальных геометрий/материалов).

---

### B. Object pool для препятствий и коллектов (useGameWorld.js)

Вместо создания новых мешей при спавне и удаления при уходе за камеру — заранее создать пул мешей (например, 30 препятствий, 20 коллектов). При спавне брать из пула (visible = true, position/rotation, userData), при уходе за камеру или после сбора — возвращать в пул (visible = false, сброс userData). Так избегаем аллокаций/GC в геймплее и уменьшаем нагрузку на сборщик мусора (важно для мобильных).

---

### C. Object pool для эффектов (useGameEffects.js)

Аналогично: пул частиц (Points) с фиксированным числом (например, 5–10 эффектов). При создании эффекта — брать из пула, инициализировать позиции/скорости; по истечении времени — не удалять, а возвращать в пул и вызывать `geometry.attributes.position.needsUpdate = true` при следующем использовании. Не создавать каждый раз новые BufferGeometry, PointsMaterial и массивы velocity — меньше аллокаций и GC.

---

### D. Один вызов updateEffects за кадр (GameRunView.vue)

Перенести `gameEffects.value.updateEffects()` из `doOneStep()` в основной цикл rAF — вызывать один раз после блока с фиксированными шагами (и после обновления камеры), перед `renderer.render()`. Эффекты привязаны ко времени, а не к игровому шагу — многократный вызов за кадр избыточен.

---

### E. Рендерер и тени (GameScene.vue)

- **Pixel ratio:** Уже ограничен `Math.min(window.devicePixelRatio, 2)` — хорошо для производительности.
- **Тени:** `shadowMap` включён, размер 2048. На слабых устройствах можно уменьшить до 1024 или отключать тени по настройке/определению слабого устройства.
- **Antialias:** `antialias: true` даёт дополнительную нагрузку. Для мобильных можно отключать или использовать FXAA в постобработке (одним проходом).

---

### F. Материалы декораций фона (useGameWorld.js)

Небо и барьеры используют `MeshStandardMaterial`. Для статичного фона можно перейти на `MeshLambertMaterial` или `MeshBasicMaterial` (без освещения) — меньше вычислений в шейдере. Визуально для далёкого фона разница часто незаметна.

---

### G. Разметка: shared geometry/material и два прохода (useGameWorld.js) ✅

**Сделано:** Одна геометрия `BoxGeometry(MARKING_WIDTH, 0.01, MARKING_LENGTH)` и один `MeshStandardMaterial` на все меши разметки; в `createLaneMarkings` создаётся `new Mesh(sharedMarkingGeometry, sharedMarkingMaterial)`, меняются только position. В `updateLaneMarkings` два прохода вместо трёх (движение + сбор minZ, затем телепорт ушедших). InstancedMesh не используется — разметка двигается и телепортируется по Z, частые обновления матриц не нужны.

---

### H. Избегать аллокаций в игровом цикле (общее)

- **effectPos** в GameRunView уже переиспользуется — хорошо.
- **getPlayerBox:** кэш Box3 уже есть в useGamePhysics; вызывать один раз за шаг (см. п. 2).
- В `updateCollectibles` не создавать временные объекты; `Math.sin(now * 0.01)` и `Math.sin(now * 0.005)` считать один раз вне цикла и использовать один pulse/offset для всех коллектов в кадре.

---

## Краткий чеклист

| Что сделать | Где | Эффект |
|-------------|-----|--------|
| Очищать roadSegments, laneMarkings и фон перед createRoad / создавать фон один раз | useGameWorld | Устранение утечки и роста draw calls |
| playerBox один раз за шаг; updateEffects один раз за кадр | GameRunView | Меньше CPU на AABB и эффекты |
| Тряска камеры в основном цикле по времени | GameRunView | Нет лишних rAF |
| Один проход updateLaneMarkings (сделано: 2 прохода) | useGameWorld | Меньше итераций |
| Shared geometry/material для разметки (сделано), препятствий, коллектов | useGameWorld | Меньше draw calls и памяти |
| Object pool препятствий и коллектов | useGameWorld | Меньше GC |
| Object pool эффектов | useGameEffects | Меньше аллокаций/GC |
| Синусы для коллектов один раз за кадр | useGameWorld | Микро-оптимизация |
| Опционально: Lambert/Basic для фона, тени 1024 или отключение на слабых | GameScene, useGameWorld | Снижение нагрузки на GPU |

Разметку дороги (логику создания линий, диапазон Z, шаг) по условию не меняем — только оптимизация кода обновления и переиспользование геометрии/материалов.
