# Анализ оптимизации раннера

## Критические логические ошибки (мешают оптимизации и стабильности)

### 1. Утечка объектов при повторном старте забега (useGameWorld.js) ✅

**Проблема:** При каждом вызове `startGame()` вызывается `clearAll()` + `createRoad()`. `clearAll()` удаляет только obstacles и collectibles. `createRoad()` не очищал старые `roadSegments`, `laneMarkings` и каждый раз добавлял новый фон.

**Исправление (сделано):** В начале `createRoad()`: удалить из scene и очистить `roadSegments.value`, `laneMarkings.value`. Фон создаётся один раз: флаг `backgroundCreated`, при повторном вызове `createBackground()` не создаём дубликаты неба/барьеров/маркеров.

---

### 2. getPlayerBox() и updateEffects вызываются многократно за кадр (GameRunView.vue) ✅

**Проблема:** В коде `playerBox` уже вычислялся один раз за `doOneStep()` и передавался в оба апдейта (до 3 вызовов getPlayerBox за кадр при 3 шагах). `updateEffects()` вызывался внутри `doOneStep()` — до 3 раз за кадр при фиксированном шаге.

**Исправление (сделано):** `updateEffects()` перенесён из `doOneStep()` в основной rAF — вызывается один раз за кадр после цикла фиксированных шагов (перед обновлением камеры). getPlayerBox остаётся один раз за шаг (логика не менялась).

---

### 3. Shake камеры через 10 requestAnimationFrame (GameRunView.vue) ✅

**Проблема:** При столкновении запускался цикл из 10 rAF подряд только для тряски камеры — конкуренция с основным циклом, возможные микрофризы.

**Исправление (сделано):** Тряска в основном цикле: при коллизии выставляется `shakeFramesLeft = 10`; в rAF после обновления камеры при `shakeFramesLeft > 0` к позиции камеры добавляется случайный сдвиг и счётчик уменьшается. Отдельные rAF для shake убраны.

---

### 4. updateLaneMarkings — три прохода по массиву (useGameWorld.js) ✅

**Проблема:** Три последовательных `laneMarkings.value.forEach`: первый двигает все разметки, второй собирает minZ по полосам, третий переносит ушедшие.

**Исправление (сделано):** Два прохода: в первом двигаем все разметки (`position.z += roadSpeed`) и по ходу считаем minZ по полосам для разметок с z <= 10; во втором переносим ушедшие (z > 10) на `minZ - stepZ + 0.05` по своей полосе.

**Важно — логика разметки (не ломать):** Разметка должна иметь одну скорость и один источник обновления. Обновление только в `updateLaneMarkings()`, вызываемом из `updateRoad()`, с `roadSpeed.value`. Если разметку двигать из двух мест или двумя разными скоростями, возникает баг «два шара»: один «шар» разметки едет со скоростью игрока/камеры, второй — с дорогой, визуально разъезжаются. При оптимизации не менять: (1) вызов только из updateRoad; (2) единственное изменение позиции — `position.z += roadSpeed.value`; (3) телепорт ушедших (z > 10) в хвост полосы по minZ.

---

### 5. Удаление из массивов obstacles/collectibles (useGameWorld.js)

**Проблема:** В `updateObstacles` и `updateCollectibles` при удалении строится массив индексов, затем `filter` создаёт новый массив. При частых удалениях — лишние аллокации. Плюс в цикле `scene.remove` вызывается сразу — порядок индексов в `obstaclesToRemove` не обратный, но filter по Set корректен. Аллокация нового массива каждый кадр при хотя бы одном удалении — нагрузка на GC.

**Исправление:** Object pool для препятствий и коллектов: не удалять меши, а деактивировать (visible = false, position в пул) и переиспользовать при спавне. Тогда не нужно каждый раз делать filter и аллокации.

---

## Рекомендуемые оптимизации (без изменения разметки дороги)

### A. Переиспользование геометрии и материалов (useGameWorld.js) ✅

**Сделано:**
- **Разметка:** Одна геометрия и один материал (уже было).
- **Препятствия:** Две геометрии по высоте (0.9 и 2.5), три материала по типу (IMPASSABLE, JUMP, ROLL). При создании — `new Mesh(sharedObstacleGeometry[def.height], sharedObstacleMaterial[kind])`.
- **Коллекты:** Одна геометрия и один материал для внешнего куба (0.6), одна геометрия и один материал для внутреннего (0.4). Группа из двух мешей с shared geometry/material.

Меньше draw calls и памяти, логика спавна и коллизий не менялась.

---

### B. Object pool для препятствий и коллектов (useGameWorld.js)

Вместо создания новых мешей при спавне и удаления при уходе за камеру — заранее создать пул мешей (например, 30 препятствий, 20 коллектов). При спавне брать из пула (visible = true, position/rotation, userData), при уходе за камеру или после сбора — возвращать в пул (visible = false, сброс userData). Так избегаем аллокаций/GC в геймплее и уменьшаем нагрузку на сборщик мусора (важно для мобильных).

---

### C. Object pool для эффектов (useGameEffects.js)

Аналогично: пул частиц (Points) с фиксированным числом (например, 5–10 эффектов). При создании эффекта — брать из пула, инициализировать позиции/скорости; по истечении времени — не удалять, а возвращать в пул и вызывать `geometry.attributes.position.needsUpdate = true` при следующем использовании. Не создавать каждый раз новые BufferGeometry, PointsMaterial и массивы velocity — меньше аллокаций и GC.

---

### D. Один вызов updateEffects за кадр (GameRunView.vue) ✅

Сделано: `updateEffects()` вызывается один раз за кадр в rAF после цикла фиксированных шагов (в том же блоке, где `gameRun.isRunning`), перед обновлением камеры и рендером.

---

### E. Рендерер и тени (GameScene.vue)

- **Pixel ratio:** Уже ограничен `Math.min(window.devicePixelRatio, 2)` — хорошо для производительности.
- **Тени:** `shadowMap` включён, размер 2048. На слабых устройствах можно уменьшить до 1024 или отключать тени по настройке/определению слабого устройства.
- **Antialias:** `antialias: true` даёт дополнительную нагрузку. Для мобильных можно отключать или использовать FXAA в постобработке (одним проходом).

---

### F. Материалы декораций фона (useGameWorld.js)

Небо и барьеры используют `MeshStandardMaterial`. Для статичного фона можно перейти на `MeshLambertMaterial` или `MeshBasicMaterial` (без освещения) — меньше вычислений в шейдере. Визуально для далёкого фона разница часто незаметна.

---

### G. Разметка: shared geometry/material и два прохода (useGameWorld.js) ✅

**Сделано:** Одна геометрия `BoxGeometry(MARKING_WIDTH, 0.01, MARKING_LENGTH)` и один `MeshStandardMaterial` на все меши разметки; в `createLaneMarkings` создаётся `new Mesh(sharedMarkingGeometry, sharedMarkingMaterial)`, меняются только position. В `updateLaneMarkings` два прохода вместо трёх (движение + сбор minZ, затем телепорт ушедших). InstancedMesh не используется — разметка двигается и телепортируется по Z, частые обновления матриц не нужны.

---

### H. Избегать аллокаций в игровом цикле (общее) ✅

- **getPlayerBox:** кэш Box3 в useGamePhysics, один вызов за шаг.
- В `updateCollectibles` pulse и offsetY (sin от now) считаются один раз до цикла по коллектам и переиспользуются в кадре — сделано.

---

## Краткий чеклист

| Что сделать | Где | Эффект |
|-------------|-----|--------|
| Очищать roadSegments, laneMarkings; фон один раз ✅ | useGameWorld | Устранение утечки |
| playerBox один раз за шаг; updateEffects один раз за кадр ✅ | GameRunView | Меньше CPU |
| Тряска камеры в основном цикле ✅ | GameRunView | Нет лишних rAF |
| updateLaneMarkings: 2 прохода ✅ | useGameWorld | Меньше итераций |
| Shared geometry/material: разметка, препятствия, коллекты ✅ | useGameWorld | Меньше draw calls и памяти |
| Синусы для коллектов один раз за кадр ✅ | useGameWorld | Микро-оптимизация |
| Object pool препятствий и коллектов | useGameWorld | Меньше GC |
| Object pool эффектов | useGameEffects | Меньше аллокаций/GC |
| Опционально: Lambert/Basic для фона, тени 1024 или отключение на слабых | GameScene, useGameWorld | Снижение нагрузки на GPU |

Разметку дороги (логику создания линий, диапазон Z, шаг) по условию не меняем — только оптимизация кода обновления и переиспользование геометрии/материалов.

---

## Микрофризы при высокой скорости

При высокой скорости (gameSpeed до 0.45) чаще срабатывает MAX_STEPS = 3 — за кадр выполняется до 3× doOneStep(), значит до 3× вызовов updateRoad, updateLaneMarkings, updateObstacles, updateCollectibles и getPlayerBox(). Плюс больше препятствий/коллектов в массивах (дистанция растёт быстрее, спавн чаще).

**Что влияет на микрофризы при высокой скорости:**

| Источник | Где | Что делать |
|----------|-----|------------|
| **reduce в цикле updateRoad** | useGameWorld | Раньше: при каждом сегменте с z > cutoffZ вызывался reduce по всем сегментам. **Сделано:** minZ по сегментам считается один раз до цикла, при переносе сегмента обновляется minZ — без reduce в цикле. |
| **filter при удалении obstacles/collectibles** | useGameWorld | Каждое удаление создавало новый массив (Set + filter). При высокой скорости удалений больше → чаще аллокации и GC. **Сделано:** sort индексов по убыванию + splice(i, 1) по месту — без нового массива. |
| **getPlayerBox() 3× за кадр** | GameRunView / useGamePhysics | setFromObject( playerMesh ) обходит иерархию меша. Вызывается раз за шаг (до 3× за кадр). Кэш Box3 уже есть; уменьшить вызовы можно только при пуле/другой модели коллизий. |
| **updateLaneMarkings 3× за кадр** | useGameWorld | Два forEach по ~72 разметкам, 3× за кадр. Логику не меняем; при необходимости можно вызывать updateLaneMarkings раз за кадр (после цикла шагов), передавая суммарный roadSpeed за кадр — осторожно с «два шара». |
| **updateEffects: sort + splice + dispose** | useGameEffects | При завершении эффекта: geometry.dispose(), material.dispose() — могут давать микро-подвисание (синхронизация с GPU). Вариант: отложенный dispose (очередь, dispose на следующем кадре) или пул эффектов без dispose в геймплее. |
| **Рендер и тени** | GameScene | При высокой скорости сцена не меняется по сложности, но больше draw calls при большем числе препятствий/коллектов. Тени 2048, antialias — на слабых устройствах можно снижать. |
| **Object pool** | useGameWorld / useGameEffects | Пул препятствий и коллектов убирает аллокации при спавне/удалении и снижает нагрузку на GC — самый сильный выигрыш при длинной дистанции и высокой скорости. |
