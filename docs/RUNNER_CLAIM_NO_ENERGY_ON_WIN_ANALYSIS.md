# Анализ: при полном прохождении дистанции (победа) «Забрать» не начисляет энергию

## Контекст

Пользователи при **полном прохождении дистанции** (победа, win), нажимая кнопку **«Забрать»**, не получают энергию на баланс. Ниже разобраны фронтенд (GameRunView, useGameRun), бэкенд (game-run-complete, game-run-claim) и наиболее вероятные причины.

---

## 1. Поток при победе vs при проигрыше

### 1.1 Проигрыш (lose)

1. Игрок погибает → в игровом цикле вызывается `endGame(false)` (с задержкой после анимации).
2. `endGame(false)` по цепочке: `stopGameLoop()` → `gameRun.completeRun(false)` → после ответа сервера заполняется `completedRunData` → затем выставляются `gameOverType = 'lose'`, `showGameOver = true`.
3. Модалка результатов показывается **после** того, как `completedRunData` уже установлен. Кнопка «Забрать» при нажатии вызывает `handleClaim()` с валидными данными.

### 1.2 Победа (win) — отличие

1. Игрок доходит до конца дистанции → срабатывает победа → после замедления и анимации победы в игровом цикле выполняется:
   - сохранение энергии в `savedEnergyCollectedForModal`,
   - `gameOverType.value = 'win'`,
   - **`showGameOver.value = true`**,
   - **`endGame(true)`** — вызывается **без `await`**.
2. Модалка с кнопкой «Забрать» показывается **сразу**, а `endGame(true)` выполняется асинхронно: внутри него идёт `await gameRun.completeRun(true)` (сетевой запрос `game-run-complete/`).
3. `completedRunData` заполняется только **после** успешного ответа `completeRun()` (внутри `endGame`, после `result = await gameRun.completeRun(...)`).

Итог: есть окно в 1–3+ секунды (пока идёт запрос завершения забега), когда экран результатов уже виден и кнопка «Забрать» активна, но **`completedRunData` ещё `null`**.

---

## 2. Главная гипотеза: гонка при победе

**Поведение кнопки «Забрать»** (фрагмент из `GameRunView.vue`):

```javascript
const handleClaim = async () => {
  if (!completedRunData.value) {
    console.error('handleClaim: completedRunData is null')
    exitToMain()
    return
  }
  // ...
}
```

Кнопка блокируется только флагом `isClaiming` (`:disabled="isClaiming"`). Пока `completedRunData` не установлен, кнопка **не** заблокирована.

Если пользователь нажимает «Забрать» в момент, когда модалка уже показана, но `completeRun()` ещё не вернулся и `completedRunData` ещё не заполнен:

- `handleClaim` видит `completedRunData.value === null`,
- выполняется `exitToMain()` без вызова `game-run-claim/`,
- энергия не начисляется, пользователь возвращается на главный экран без пояснений.

Это согласуется с симптомом «при полном прохождении не получают энергию»: при победе модалка появляется раньше готовности данных, и быстрый клик по «Забрать» приводит к выходу без claim.

**Рекомендации (идеи для правок, без изменений в коде в рамках этого документа):**

- Вариант A: не показывать модалку победы до установки `completedRunData` (например, вызывать `endGame(true)` с `await` из вызывающего кода и показывать `showGameOver` только после возврата из `endGame`).
- Вариант B: показывать модалку как сейчас, но до установки `completedRunData` блокировать кнопку «Забрать» (например, `:disabled="isClaiming || !completedRunData"`) и/или показывать состояние «Подготовка результатов…», чтобы пользователь не нажимал «Забрать» до готовности данных.

---

## 3. Цепочка запросов и данные для claim

| Этап | API | Назначение |
|------|-----|------------|
| 1 | `POST energy-run-start/` | Старт забега: фиксируется `energy_run_last_started_at`, `energy_run_start_storage`, cooldown. |
| 2 | `POST game-run-complete/` | Валидация забега (дистанция, энергия, поинты, время). Энергию **не** начисляет. |
| 3 | `POST game-run-claim/` | Начисление энергии на баланс, обнуление `energy_run_start_storage` и т.д. |

Данные для «Забрать» берутся из `completedRunData`, который заполняется в `endGame()` после ответа `game-run-complete/`. При победе модалка показывается до завершения этого шага — см. п. 2.

---

## 4. Фронтенд: ключевые места

### 4.1 Где вызывается `endGame(true)` (победа)

- **Файл:** `src/views/GameRunView.vue`.
- **Место:** игровой цикл, после окончания анимации победы (порядок строк ~2010–2026):
  - сохраняется энергия в `savedEnergyCollectedForModal`,
  - выставляются `gameOverType = 'win'`, `showGameOver = true`,
  - вызывается **`endGame(true)` без `await`**.

### 4.2 Где заполняется `completedRunData`

- В той же `endGame()`:
  - вызывается `result = await gameRun.completeRun(isWinByState)`;
  - при успешном `result` (или при fallback) заполняется `completedRunData.value`;
  - только после этого, при необходимости, обновляется модалка (`if (!showGameOver.value) { ... }`). При победе модалка уже открыта, поэтому ветка «показать модалку» для win внутри `endGame` не выполняется — модалка была показана раньше, до установки `completedRunData`.

### 4.3 Кнопка «Забрать»

- `:disabled="isClaiming"` — блокировка только на время запроса claim.
- Нет проверки `completedRunData` для блокировки кнопки.
- При `!completedRunData.value` в `handleClaim` выполняется только `exitToMain()` без запроса claim.

### 4.4 Payload claim

- `handleClaim` отправляет только то, что пришло из `completedRunData`:
  - `energy_collected: completedRunData.value.energy_collected`
  - `is_win: completedRunData.value.is_win`
- При победе бэкенд при валидных данных начисляет всю `energy_collected` (см. п. 5).

---

## 5. Бэкенд: начисление при claim

### 5.1 GameRunClaimView (`edit/core/views.py`)

- Проверяется, что забег был начат (`energy_run_last_started_at`) и не истёк (2 часа).
- Проверяется наличие данных забега: `energy_run_start_storage is not None`. Если `None` — идёт проверка идемпотентности по `energy_run_claimed_at`; при неуспехе возвращается 400 «Run data not found».
- Из запроса берутся `energy_collected` и `is_win`.
- При **`is_win=True`**: `final_energy = energy_collected` (вся собранная энергия).
- При проигрыше считается процент сохранения и т.д.
- Далее: обновление `UserProfile.energy`, `WalletInfo.kw_amount`, статистика, обнуление `energy_run_start_storage`, установка `energy_run_claimed_at`, ответ 200 с `success`, `energy_gained`, `total_energy`, `storage`, `power`.

Специальной логики, которая бы «отключала» начисление именно при победе, в коде нет. Если запрос `game-run-claim/` доходит с валидными `energy_collected` и `is_win=True` и при нём `energy_run_start_storage` ещё не обнулён — энергия начисляется.

### 5.2 GameRunCompleteView

- Валидации: забег начат, не истёк, есть `energy_run_start_storage`, проверки по `energy_collected`, поинтам (4c), времени, дистанции.
- При победе и полном сборе энергии `energy_collected` может совпадать с `energy_run_start_storage`. Валидация 4b — это `energy_collected > max_energy`; равенство допустимо.
- Валидация 4c (сумма поинтов vs `energy_collected`) допускает погрешность 0.1. В edge-case при 100% сборе и округлениях теоретически возможна рассинхронизация суммы поинтов и `energy_collected`, но это не объясняет систематическое отсутствие начисления именно при победе; скорее дало бы редкие 400 на этапе complete.

---

## 6. Другие возможные причины (второстепенные)

1. **Таймаут/сеть на `game-run-complete/`**  
   Если запрос завершения забега долго идёт или падает по таймауту, `completeRun()` может вернуть `null`/ошибку. Тогда в `endGame` используется fallback для `completedRunData`. В этом случае данные для claim всё равно могут быть заполнены из локальных сохранённых значений, и при последующем нажатии «Забрать» claim уйдёт. Но если пользователь успел нажать «Забрать» до установки `completedRunData` (в т.ч. fallback), снова сработает выход без claim — та же гонка, что в п. 2.

2. **Поле `energy_run_claimed_at`**  
   В коде используется `getattr(user_profile, 'energy_run_claimed_at', None)`. Поле есть в модели и в миграциях — при нормальной схеме БД идемпотентность не должна мешать первому claim при победе.

3. **Двойной вызов `endGame`**  
   Защита `endGame._isProcessing` уменьшает риск двойной установки данных; при повторном вызове второй раз данные не перезаписываются. Это не объясняет отсутствие начисления при первом нажатии «Забрать» при победе.

---

## 7. Итог и приоритет гипотез

| Приоритет | Гипотеза | Обоснование |
|-----------|----------|-------------|
| 1 | **Гонка при победе:** модалка показывается до установки `completedRunData`, пользователь нажимает «Забрать» до возврата `completeRun()` → в `handleClaim` срабатывает выход без вызова claim. | Отличие потока win (модалка до `endGame`/до установки `completedRunData`) от lose (модалка после). Кнопка не блокируется по `completedRunData`. Прямо ведёт к «не получил энергию» при быстром клике. |
| 2 | Таймаут/ошибка `game-run-complete/` при победе; пользователь нажимает «Забрать» до появления fallback-`completedRunData`. | Та же гонка по времени; усугубляется при плохой сети. |
| 3 | Редкие 400 на `game-run-complete/` из-за валидации поинтов при 100% сборе. | Не отменяет главную причину; может давать редкие случаи, когда `result` не success и fallback не успели «подставить» до клика. |

Рекомендуется в первую очередь устранить гонку при победе (п. 2): либо не показывать модалку победы до установки `completedRunData`, либо блокировать кнопку «Забрать» и/или показывать «Подготовка результатов…», пока `completedRunData` не готов. Дополнительно можно логировать в продакшене случаи `handleClaim` при `!completedRunData.value` (и при победе), чтобы подтвердить гипотезу по логам.

---

## 8. Связанные файлы

| Назначение | Файл |
|------------|------|
| Поток победы, модалка, handleClaim | `src/views/GameRunView.vue` |
| completeRun, payload game-run-complete | `src/composables/useGameRun.js` |
| Завершение забега (без начисления) | `edit/core/views.py` — `GameRunCompleteView` |
| Начисление при «Забрать» | `edit/core/views.py` — `GameRunClaimView` |
| Общий разбор claim и ошибок | `docs/RUNNER_ENERGY_CLAIM_ANALYSIS.md` |

Правки по коду в рамках этого анализа не вносятся; документ подготовлен только для диагностики и планирования исправлений.
