# Анализ раннера и ошибки «Ошибка при начислении энергии»

## 1. Контекст

Пользователи иногда видят сообщение **«Ошибка при начислении энергии»**. Ошибка не у всех и не постоянная, что указывает на возможную связь с качеством интернет-соединения. В документе разобраны поток начисления энергии, точки отказа и идея проверки соединения при предзагрузке.

---

## 2. Архитектура потока раннера (начисление энергии)

### 2.1 Последовательность запросов

| Этап | Действие пользователя | API | Назначение |
|------|------------------------|-----|------------|
| 1 | Нажимает «Старт» (после загрузки моделей) | `POST energy-run-start/` | Фиксирует старт забега, сохраняет `energy_run_last_started_at`, `energy_run_start_storage`, обнуляет `storage`. Cooldown 60 мин. |
| 2 | Играет, забег завершается (win/lose) | `POST game-run-complete/` | Валидация данных забега (дистанция, энергия, поинты, время). **Энергию не начисляет** — только возвращает расчёт. |
| 3 | Нажимает «Забрать» на экране результатов | `POST game-run-claim/` | **Начисление энергии** на баланс, обновление WalletInfo, очистка `energy_run_start_storage`. |

Начисление происходит **только** в шаге 3 (`game-run-claim/`). Сообщение «Ошибка при начислении энергии» показывается при любой ошибке именно этого запроса.

### 2.2 Где показывается ошибка (фронтенд)

- **Файл:** `src/views/GameRunView.vue`
- **Функция:** `handleClaim` (примерно строки 2575–2638)

```javascript
const response = await host.post('game-run-claim/', {
  energy_collected: completedRunData.value.energy_collected,
  is_win: completedRunData.value.is_win
})
// ...
} catch (error) {
  console.error('Ошибка при начислении энергии:', error)
  alert(error.response?.data?.error || 'Ошибка при начислении энергии')
}
exitToMain()
```

Текст в `alert` берётся из `error.response?.data?.error` при ответе сервера или подставляется строка по умолчанию при сетевой ошибке (нет ответа).

### 2.3 Откуда берутся данные для «Забрать»

- `completedRunData` заполняется в `endGame()` после вызова `gameRun.completeRun(isWinByState)`.
- Если `game-run-complete/` успешен — в `completedRunData` попадают данные с сервера (`energy_collected`, `is_win`, `energy_gained`).
- Если `game-run-complete/` падает (сеть/таймаут) — `result` приходит `null`, используется локальный fallback: `savedEnergyBeforeComplete`, `savedEnergyCollectedForModal` и т.д. Модалка результатов всё равно показывается, кнопка «Забрать» доступна.

Важно: на бэкенде **`game-run-complete/` не меняет** `energy_run_start_storage` — он выставляется при `energy-run-start/`. Поэтому даже при неудачном `game-run-complete/` пользователь может нажать «Забрать», и `game-run-claim/` с точки зрения бэкенда валиден (если запрос дойдёт).

---

## 3. Причины ошибки «Ошибка при начислении энергии»

Ошибка возникает в `catch` при вызове `host.post('game-run-claim/', ...)`. Возможные причины:

### 3.1 Сетевые (наиболее вероятно при «не у всех»)

- Таймаут запроса (у axios в проекте **таймаут не задан** — см. `axios.config.js`).
- Обрыв соединения, reset, нестабильный канал.
- Очень высокая задержка: запрос висит долго, пользователь может перезагрузить страницу или соединение обрывается по таймауту на стороне прокси/оператора.

Итог: на клиенте — исключение, в `error.response` может не быть данных → показывается дефолтное «Ошибка при начислении энергии». На сервере запрос может так и не дойти, либо дойти с задержкой.

### 3.2 Ответы бэкенда 4xx

- **400 Run not started** — нет `energy_run_last_started_at`.
- **400 Run data not found** — `energy_run_start_storage is None` (уже обнулён после предыдущего успешного claim или аномалия).
- **400 Run expired** — с момента `energy_run_last_started_at` прошло > 2 часов (7200 сек).
- **400 Invalid energy_collected** — отрицательное значение.
- **400 Energy collected exceeds maximum allowed** — `energy_collected` > `energy_run_start_storage`.

В этих случаях в `error.response?.data?.error` может быть текст от сервера; он и показывается в `alert`, иначе — снова дефолтная строка.

### 3.3 Ответы бэкенда 5xx

- Любая необработанная ошибка в `GameRunClaimView` (edit/core/views.py) возвращает 500 и сообщение в `error.response?.data?.error`. Пользователь видит общую или техническую формулировку.

---

## 4. Связь с интернетом

- Ошибка **не у всех и не постоянная** хорошо согласуется с сетевыми проблемами: нестабильный Wi‑Fi, мобильный интернет, перегрузка канала, таймауты на маршруте.
- Критичный момент — один запрос `game-run-claim/`: если он не дошёл или ответ не вернулся к клиенту, пользователь видит «Ошибка при начислении энергии», при этом бэкенд мог:
  - не получить запрос (энергия не начислена);
  - получить и начислить, но ответ не дошёл до клиента (редко, но возможно — тогда при следующем заходе энергия уже будет на балансе, повторный claim получит 400 Run data not found).

---

## 5. Текущее состояние клиента (таймауты, retry)

- **axios (host):** в `axios.config.js` для `host` **не задан `timeout`** — запросы могут висеть до обрыва соединения.
- **Повтор при ошибке:** в `handleClaim` **нет retry** — одна попытка, при любой ошибке — `alert` и `exitToMain()`.
- **Предзагрузка:** перед стартом забега идёт предзагрузка моделей (`preloadAllModels` в `onSceneReady`), но проверки качества сети или пинга до API нет.

---

## 6. Идея: проверка пинга/соединения при предзагрузке

Цель: до старта забега оценить качество соединения и, если оно плохое, предупредить пользователя, чтобы он по возможности перешёл на более стабильную сеть.

### 6.1 Что можно делать

- **В момент предзагрузки** (например, после/во время загрузки моделей или перед показом кнопки «Старт») выполнить несколько лёгких запросов к бэкенду (например, HEAD или GET к быстрому эндпоинту) и замерить RTT.
- Либо использовать один быстрый эндпоинт (например, проверка авторизации или специальный `ping/`), за несколько попыток вычислить средний/максимальный пинг.
- Если пинг выше заданного порога (например, > 500–1000 ms) или доля неудачных запросов выше порога — показать модалку/сообщение: «Соединение нестабильное. Для корректного начисления энергии рекомендуем перейти на стабильный интернет (Wi‑Fi или хороший мобильный сигнал). Продолжить?» с кнопками «Продолжить» / «Отмена».

### 6.2 Важные моменты

- Не блокировать запуск игры намертво: либо предупреждение с возможностью «Всё равно играть», либо только информирование без блокировки.
- Порог по пингу и количество замеров подобрать по реальным метрикам (чтобы не пугать пользователей с нормальным мобильным интернетом).
- Учитывать, что пинг при предзагрузке не гарантирует такое же качество в момент нажатия «Забрать» через несколько минут, но снижает долю заходов с заведомо плохим каналом.

### 6.3 Где в коде это удобно встроить

- **GameRunView.vue:** после успешной предзагрузки моделей (`preloadAllModels`), когда показывается блок с кнопками («Старт», «Тренировка», «Настройки», «Назад») — перед или сразу после `showLoadingSuccess` можно запустить проверку пинга и при плохом результате показать модалку/предупреждение.
- Альтернатива: проверка в момент первого отображения экрана раннера (до кнопки «Старт»), чтобы не затягивать ожидание после нажатия «Старт».

---

## 7. Дополнительные улучшения (на будущее, без правок в этом документе)

- **Таймаут для API:** задать разумный `timeout` для `host` (axios) в `axios.config.js`, чтобы не ждать бесконечно (например, 15–30 сек для claim).
- **Retry для game-run-claim:** при сетевой ошибке или таймауте дать пользователю кнопку «Повторить» на экране результатов вместо немедленного выхода; при успехе — обновить баланс и затем выйти.
- **Явные сообщения:** различать в UI «сетевая ошибка / таймаут» и «ошибка сервера (400/500)», чтобы пользователь понимал, что можно попробовать ещё раз или сменить сеть.
- **Идемпотентность / повторный claim:** на бэкенде при повторном запросе claim после уже успешного начисления возвращать 400 с понятным текстом («Энергия уже начислена») и не обнулять данные повторно — чтобы не путать логику и поддержку.

---

## 10. Улучшения для максимальной успешности начисления

Ниже — список изменений по приоритету: от быстрых и высокоэффективных до более трудоёмких.

### 10.1 Клиент: не выходить при ошибке, дать «Повторить»

**Сейчас:** при любой ошибке `handleClaim` вызывается `exitToMain()` — пользователь теряет экран результатов и не может повторить запрос без нового забега.

**Сделать:** при ошибке не вызывать `exitToMain()`, оставить экран результатов; показывать сообщение об ошибке и кнопку **«Повторить»** рядом с «Забрать» (или заменить «Забрать» на «Повторить» до успеха). После успешного claim — тогда уже очистить данные и выйти.

**Эффект:** один обрыв сети не приводит к потере забега; пользователь может нажать «Повторить» после восстановления связи.

---

### 10.2 Клиент: автоматический retry с таймаутом (только для сетевых ошибок)

**Сделать:** для запроса `game-run-claim/` задать `timeout` (например, 20–30 сек). При ошибке без `error.response` (сеть/таймаут) — 2–3 автоматические повторные попытки с паузой 2–5 сек. Если после retry успех — обработать как обычно. Если все попытки неудачны — показать сообщение и кнопку «Повторить» (как в 10.1).

**Эффект:** кратковременные сбои и таймауты часто преодолеваются без участия пользователя.

---

### 10.3 Клиент: различать тип ошибки в сообщении

**Сделать:** в `catch` определять тип ошибки:
- нет `error.response` или `error.code === 'ECONNABORTED'` → «Проблема с интернетом. Проверьте соединение и нажмите «Повторить».»
- 400 с `error.response?.data?.error` → показывать текст сервера или короткий маппинг (например, «Забег истёк» для Run expired).
- 5xx → «Временная ошибка сервера. Попробуйте «Повторить» через несколько секунд.»

**Эффект:** пользователь понимает, что делать (проверить сеть vs подождать), и не путает с «энергию не начислили навсегда».

---

### 10.4 Бэкенд: идемпотентность claim при повторном запросе (без двойного начисления)

**Критическое правило:** один забег = одно начисление энергии. Повторные вызовы `game-run-claim/` для уже начисленного забега **ни при каких условиях не должны** снова увеличивать баланс (energy, kw_amount, total_energy_accumulated и т.д.). Идемпотентность = «при повторном запросе вернуть успех и актуальные данные, но не кредитовать энергию повторно».

**Сценарий:** первый `game-run-claim/` прошёл успешно, начислил энергию, но ответ не дошёл до клиента (таймаут/обрыв). Клиент нажимает «Повторить» → второй запрос claim. Сейчас бэкенд уже обнулил `energy_run_start_storage`, поэтому вернёт **400 Run data not found** — пользователь видит ошибку, хотя энергия уже начислена.

**Сделать:** завести явный признак «claim по этому забегу уже выполнен» (например, поле `energy_run_claimed_at` в профиле или отдельная запись в логе/таблице). При **первом** успешном claim — начислить энергию, выставить признак, обнулить `energy_run_start_storage`. При **повторном** запросе (признак уже выставлен для этого забега):
- **не выполнять** повторное начисление (не увеличивать energy, не обновлять WalletInfo.kw_amount, не трогать GlobalSpendStats и графики);
- возвращать **200** с текущими данными: `success: true`, `energy_gained` (то значение, что было начислено при первом claim), `total_energy` (текущий баланс из БД), `storage`, `power`;
- в ответ добавить `already_claimed: true`, чтобы клиент показал «Энергия уже была начислена» и обновил UI из ответа.

Альтернатива без нового поля: если `energy_run_start_storage is None` и при этом недавно (например, в последние 5–10 мин) по логам/аудиту был успешный claim для этого пользователя — возвращать 200 с текущим балансом и `already_claimed: true`, **без любого кода, который меняет energy/kw_amount**. Иначе оставить 400.

**Эффект:** при «успех на сервере, ответ не дошёл» повторное нажатие «Повторить» не даёт ошибку и не дублирует начисление; пользователь видит подтверждение и актуальный баланс.

---

### 10.5 Сохранение данных забега в sessionStorage

**Сделать:** при установке `completedRunData` (в `endGame`) дополнительно записывать в `sessionStorage` ключ вида `runner_completed_run` с JSON `{ energy_collected, is_win, energy_gained, timestamp }`. При монтировании GameRunView (или при показе экрана результатов) проверять: если есть данные в sessionStorage и они не старше 2 часов — восстановить `completedRunData` и показать экран результатов с кнопкой «Забрать». После успешного claim (или при выходе без claim) — удалить ключ из sessionStorage.

**Эффект:** при закрытии вкладки/краше после завершения забега, но до нажатия «Забрать», пользователь может вернуться в раннер и всё ещё увидеть результаты и нажать «Забрать».

---

### 10.6 Таймаут для host (axios)

**Сделать:** в `axios.config.js` для инстанса `host` задать `timeout: 25000` (25 сек) глобально или для критичных запросов (claim, complete) передавать `timeout` в config конкретного вызова. Чтобы не резать другие запросы — можно задать таймаут только в `handleClaim` и при вызове `completeRun`.

**Эффект:** запрос не висит бесконечно; пользователь быстрее получает ошибку и может нажать «Повторить».

---

### 10.7 Опционально: повтор game-run-complete при ошибке

**Сейчас:** если `game-run-complete/` падает по сети, модалка всё равно показывается с локальными данными, и claim валиден (данные старта уже на сервере). Повтор complete не обязателен для начисления.

**Опция:** при показе экрана результатов, если `result` был `null` (complete не удался), в фоне один раз отправить повторный `game-run-complete/` с теми же данными. При успехе можно обновить `completedRunData` с сервера (для консистентности расчёта energy_gained). Не блокировать кнопку «Забрать» — пользователь может жать «Забрать» независимо.

**Эффект:** на сервере будет полная валидация забега; полезно для аудита и логики, на успешность claim влияет косвенно.

---

### 10.8 Проверка соединения перед показом «Забрать»

**Опция:** перед первым отображением кнопки «Забрать» (или при первом нажатии) выполнить один лёгкий запрос (например, GET к эндпоинту с минимальным ответом). Если запрос не прошёл за 3–5 сек — сразу показать подсказку: «Соединение нестабильно. Проверьте интернет и нажмите «Забрать» снова.» Кнопку «Забрать» оставить активной.

**Эффект:** пользователь заранее видит предупреждение и может переключиться на Wi‑Fi или подождать, не теряя забег.

---

### 10.9 Приоритет внедрения (кратко)

| Приоритет | Улучшение | Сложность | Влияние на успешность |
|-----------|-----------|-----------|------------------------|
| 1 | 10.1 — не выходить при ошибке, кнопка «Повторить» | Низкая | Очень высокое |
| 2 | 10.4 — идемпотентность claim на бэкенде | Средняя | Высокое (случай «ответ не дошёл») |
| 3 | 10.2 — retry + timeout для claim | Низкая | Высокое |
| 4 | 10.3 — разные сообщения по типу ошибки | Низкая | Среднее (UX и доверие) |
| 5 | 10.6 — таймаут axios | Низкая | Среднее |
| 6 | 10.5 — sessionStorage для восстановления экрана | Средняя | Среднее (краш/закрытие вкладки) |
| 7 | 10.8 — проверка связи перед «Забрать» | Низкая | Доп. информирование |
| 8 | 10.7 — повтор complete в фоне | Низкая | Низкое (аудит) |

---

### 10.10 Требование: запрет дублирования начисления (обязательно)

При внедрении любых улучшений (retry, «Повторить», идемпотентность) необходимо соблюдать:

- **Один завершённый забег = максимум одно фактическое начисление энергии.** Второй и последующие запросы `game-run-claim/` для того же забега не должны снова увеличивать:
  - `UserProfile.energy`,
  - `WalletInfo.kw_amount`,
  - `GlobalSpendStats.total_energy_accumulated`,
  - любые графики/агрегаты по начисленной энергии.

- **Бэкенд — единственный источник истины.** Только сервер решает, был ли claim по данному забегу уже выполнен. Клиент может повторять запрос при ошибках; сервер обязан по идентификатору забега (например, пара `energy_run_last_started_at` + факт «claim уже был») либо выполнить начисление один раз, либо вернуть успех без повторного начисления (идемпотентность).

- **Клиент не должен полагаться на «мы уже отправили claim»** для блокировки повторной отправки в целях экономии — пользователь может нажать «Повторить» несколько раз. Защита от дубля только на бэкенде.

- При реализации п. 10.4 обязательно ввести явный признак «claim выполнен» (поле или запись) и в коде начисления проверять: если уже выполнено — пропускать все `update`/`F("energy") + ...` и возвращать только 200 с текущим состоянием.

---

## 8. Краткая схема потока (для отладки)

```
[Старт]
  → energy-run-start/  (storage, cooldown, energy_run_start_storage, energy_run_last_started_at)
  → startGame()
[Игра]
  → сбор энергии, препятствия, win/lose
[Конец забега]
  → endGame(isWin)
  → gameRun.completeRun(isWin)  →  game-run-complete/  (только валидация, без начисления)
  → completedRunData = result || fallback(local)
  → showGameOver = true, модалка с кнопкой «Забрать»
[Нажатие «Забрать»]
  → handleClaim()
  → host.post('game-run-claim/', { energy_collected, is_win })
  → при успехе: обновление app/wallet, очистка completedRunData, exitToMain()
  → при ошибке: alert('Ошибка при начислении энергии' или error.response?.data?.error), exitToMain()
```

---

## 9. Файлы для правок (когда будете делать изменения)

| Задача | Файлы |
|--------|--------|
| Текст ошибки, retry, различие сеть/сервер | `src/views/GameRunView.vue` (handleClaim, модалка результатов) |
| Проверка пинга при предзагрузке | `src/views/GameRunView.vue` (preloadAllModels / onSceneReady, новый composable или утилита) |
| Таймаут axios | `axios.config.js` (или где создаётся `host`) |
| Локализация сообщений | `src/locales/ru.json`, `en.json`, `uk.json` (ключи в `notification.*`) |
| Бэкенд claim (идемпотентность, сообщения) | `edit/core/views.py` — `GameRunClaimView` |

---

## 11. Локализованные уведомления (notification)

В стиле проекта (как «Кошелёк не подключен», «Недостаточно средств для улучшения») добавлены ключи в `notification` в `ru.json`, `en.json`, `uk.json`. Использование: модалка через `ModalNew` с `status`, `title: t('notification.st_error')` или `t('notification.st_attention')`, `body: t('notification.<key>')`, либо `alert(t('notification.<key>'))`.

| Ключ | Назначение |
|------|------------|
| `notification.wallet_not_connected` | Кошелёк не подключен |
| `notification.insufficient_funds_upgrade` | Недостаточно средств для улучшения |
| `notification.energy_claim_error` | Общая ошибка при начислении энергии |
| `notification.energy_claim_network_error` | Проблема с интернетом, нажмите «Повторить» |
| `notification.energy_claim_run_expired` | Забег истёк, начните новый |
| `notification.energy_claim_server_error` | Временная ошибка сервера, попробуйте «Повторить» |
| `notification.energy_claim_already_claimed` | Энергия уже начислена (идемпотентность) |
| `notification.energy_claim_run_not_started` | Забег не был начат |
| `notification.energy_claim_run_data_not_found` | Данные забега не найдены |
| `notification.energy_claim_invalid_energy` | Некорректные данные энергии |
| `notification.energy_claim_retry_btn` | Кнопка «Повторить» |
| `notification.connection_unstable_pre_run` | Предупреждение о нестабильном соединении до старта забега |
| `notification.connection_unstable_before_claim` | Подсказка перед «Забрать» |
| `notification.energy_claim_success` | Успешное начисление энергии |

**Пример в коде (handleClaim при ошибке):**
```javascript
const isNetworkError = !error.response || error.code === 'ECONNABORTED'
const body = isNetworkError
  ? t('notification.energy_claim_network_error')
  : (error.response?.status >= 500
      ? t('notification.energy_claim_server_error')
      : (error.response?.data?.error || t('notification.energy_claim_error')))
// Показать ModalNew: status="error", title=t('notification.st_error'), body=body
// Или для already_claimed от сервера: body=t('notification.energy_claim_already_claimed')
```

Документ подготовлен только как анализ; правки в коде планируются отдельно.
