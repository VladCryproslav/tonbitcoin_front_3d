# Раннер: исправление 400 game-run-complete и идея «Runner storage»

## 1. Исправление 400 «Energy collected does not match collected points»

### Причина

- Клиент ограничивает `energy_collected` по storage: `limitedEnergyCollected = Math.min(savedEnergyCollected, savedStartStorage)` (например 875).
- Сумма сырых поинтов из-за накопления float даёт `collectedPointsSum` больше (например 889.51).
- В `game-run-complete` отправлялись сырые поинты без нормализации.
- Бэкенд (проверка 4c2) требует `|points_sum - energy_collected| <= 0.01`, поэтому возвращался 400.

### Решение (внесено в код)

В **`src/composables/useGameRun.js`** в `completeRun` перед отправкой:

- Если сумма поинтов уже совпадает с `limitedEnergyCollected` в пределах 0.02 — отправляем поинты как есть (с округлением до 2 знаков).
- Иначе **нормализуем** поинты: масштабируем каждый `value` с коэффициентом `limitedEnergyCollected / collectedPointsSum`, последний поинт подгоняем так, чтобы сумма в точности равнялась `limitedEnergyCollected` (с округлением до 2 знаков). Так сервер получает `collected_points`, сумма которых равна `energy_collected`, и 4c2 проходит.

Кнопка «Забрать» и `game-run-claim` при этом не менялись и работают как раньше.

---

## 2. Идея поля «Runner storage» (накопление по ходу забега)

### Суть

Добавить поле, которое заполняется по мере забега и отражает «сколько пользователь уже собрал» в текущем забеге. Оно не должно превышать **Energy run start storage** (текущий `energy_run_start_storage`).

Сейчас:

- На сервере при старте забега фиксируется только `energy_run_start_storage` и `energy_run_last_started_at`.
- Фактическое «сколько собрал» считается на клиенте (`energyCollected`, поинты) и один раз отправляется в `game-run-complete` и потом в `game-run-claim`.

Идея: иметь на бэкенде поле «Runner storage» (или `energy_run_collected_so_far`), которое обновляется по мере сбора (каждый собранный токен = запрос/событие).

### Варианты реализации

| Вариант | Описание | Нагрузка на сервер |
|--------|----------|---------------------|
| **A. Обновление при каждом collect на клиенте** | При каждом `collectEnergy(amount)` клиент шлёт запрос (например `PATCH game-run-collect/` с `amount`). Сервер увеличивает `runner_storage` на `amount`, но не выше `energy_run_start_storage`. | **Высокая**: 50–100+ запросов за один забег на пользователя. |
| **B. Периодический sync (раз в N секунд)** | Клиент раз в 5–10 сек отправляет текущее `energyCollected`. Сервер записывает в `runner_storage` (не больше start_storage). | **Средняя**: 10–20 запросов за забег на пользователя. |
| **C. Только в complete/claim** | Никакого нового поля «по ходу». В `game-run-complete` и `game-run-claim` уже передаётся итоговое `energy_collected`. Сервер может сохранять его в отдельное поле «последний собранный объём за забег» для аналитики, без новых запросов. | **Нулевая** дополнительная нагрузка. |

### Ограничение «не больше Energy run start storage»

В любом варианте:

- Сервер должен проверять: `runner_storage` (или аналог) ≤ `energy_run_start_storage`.
- При первом запросе после старта забега можно инициализировать поле 0; дальше только увеличивать, с cap по `energy_run_start_storage`.

### Нагрузка при 200–300 активных пользователей, 100 одновременно в забеге

- **Сейчас (без Runner storage по ходу забега):**  
  На один забег: 1× `energy-run-start`, 1× `game-run-complete`, 1× `game-run-claim`.  
  100 одновременных забегов ≈ 100 complete + до 100 claim в пике. Для типичного бэкенда это **небольшая** нагрузка.

- **Вариант A (запрос на каждый collect):**  
  ~50–100 запросов на забег × 100 игроков = **5 000–10 000 запросов** в период одного «раунда» забегов. Это уже существенная нагрузка и лишняя задержка для клиента.

- **Вариант B (sync раз в 5–10 сек):**  
  ~10–20 запросов на забег × 100 игроков = **1 000–2 000 запросов**. Нагрузка умеренная, но выше текущей.

- **Вариант C:**  
  Без дополнительных запросов — нагрузка не меняется.

**Вывод:** идея «всегда знать, сколько пользователь собрал» за счёт обновления на сервере по каждому токену (или даже раз в несколько секунд) при 100 одновременных игроках **заметно нагрузит** сервер по сравнению с текущей схемой. Если нужно только «знать итог после забега» — текущая схема (complete + claim) уже это даёт; при желании можно сохранять последнее `energy_collected` в отдельное поле в момент complete/claim (вариант C) без новых запросов по ходу забега.

---

## 3. Рекомендации

1. **400 по game-run-complete** — исправлено нормализацией поинтов на клиенте в `useGameRun.js`.
2. **Runner storage по ходу забега** — если вводить, то предпочтительно **вариант C** (сохранять итог в complete/claim без доп. запросов). Варианты A и B при 100 одновременных игроках дадут ощутимый рост нагрузки.
3. Если нужно именно «живое» значение на сервере во время забега — минимизировать частоту (вариант B с интервалом 10–15 сек и не чаще) и учитывать лимит `energy_run_start_storage` при каждом обновлении.
